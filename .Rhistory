round(AreaTotal / nACE$ndsej, 0), " ha.")
NotaDeRodape <- paste0(IAS, IAI)
quadroACE <- as.data.frame(
tibble(
Estrato    = ACE$estimation$area,
LimInf95   = confint(ACE)$ci$ci_lower_op,
Estimativa = ACE$estimation$estimate,
LimSup95   = confint(ACE)$ci$ci_upper_op,
Variância  = ACE$estimation$variance,
n          = ACE$estimation$n2))
quadroACE %>%
kbl(caption = paste0("Amostragem Casual Estratificada em ~",
round(AreaTotal, 0), " ha."), align = "r") %>%
kable_classic(full_width = F) %>%
footnote(general       = NotaDeRodape,
general_title = "Intensidade amostral",
footnote_as_chunk = T)
fun_erroSimulacoes = function(sd, volumeMed, alpha = 0.05, n) {
t = qt(1 - alpha/2, n - 1)
E = ((sd * t)/volumeMed) * 100
return(E)
}
nParcelas = c(20, 15, 10, 6, 5, 4, 3, 2) # Número de parcelas de campo
areaTotal = sum(talhoes$area)
# Simulações de Intensidade Amostral na Amostragem Dupla Simples
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
erroSimulacoes_ADS = round(fun_erroSimulacoes(sd = sqrt(reg2p_nex$estimation$g_variance),
volumeMed = mean(X$VTCC[!is.na(X$VTCC)]), n = nParcelas), 2)
prjNome  <- "PRJ_InvModelo"
dirNome  <- paste0('C:/GitHub/', prjNome, '/DADOS/')
arqNome_metricas  <- paste0(dirNome, prjNome, '_Metricas.xlsx')
arqNome_grid <- paste0(dirNome, prjNome, '.xlsx')
metricas     <- import(arqNome_metricas)
grid     <- import(arqNome_grid, which = "grid")
talhoes <- import(arqNome_grid, which = "talhoes")
# Mescla as métricas LiDAR com o Grid através da coluna "gridcell". Células do
# grid cuja área é menor do que 1m² são descartadas.
grid_laz <- merge(grid, metricas, by = "gridcell") %>%
filter_at(vars(areacell), all_vars(. >= 1))
# Seleciona colunas de interesse
X <- tibble(grid_laz) %>% select(fase, areacell, idade, zmean,
zsd, pzabovezmean, zq30, zq75, zq95, MHDOM, VTCC)
X$fase <- as.numeric(X$fase) # Converte a coluna "fase" para o tipo numérico
X$boundaryweights <- X$areacell / 400 # Cria a coluna "boundaryweights"
X <- as.data.frame(X) # Tibble não é uma função nativa do R, é uma função chamada pelo tidyverse. Dessa forma, o formato da tabela que é gerada não é reconhecido pela função twophase() do package forestinventory. O forestinventory reconhece data frames, já que são nativos do R.
# Análise de regressão linear para verificar a correlação
# entre o p95 e a idade do inventário com o VTCC
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
m <- lm(VTCC ~ zq95 + idade, data = X)    # Análise de Regressão Linear
summary(m)                          # Mostra os resultados da regressão
VTCCparcelas <- X$VTCC[!is.na(X$VTCC)] # VTCCparcelas recebe os valores não nulos de VTCC contidos em X, ou seja, recebe os valores de VTCC das parcelas de campo
plot(VTCCparcelas, predict(m))              # Gráfico de observado vs predito
abline(0,1)
# Dupla Amostragem Casual
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
reg2p_nex <- twophase(formula = VTCC ~ zq95 + idade, # formula relaciona os valores de VTCC com zq95 e IDINV (análise de regressão)
data = X, #  Base de dados utilizada
boundary_weights = "boundaryweights",
phase_id = list(phase.col = "fase", terrgrid.id = 2)) # phase_id recebe uma lista em que a coluna a ser analisada é a "Inventario" e o identificador da segunda fase é 2
summary(reg2p_nex) # Dá os resultados da Dupla Amostragem
confint(reg2p_nex) # Estatística de confiança
# Dupla Amostragem Estratificada
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
reg2p_nex_est = twophase(
formula = VTCC ~ zq95 + idade,
data = X,
phase_id =list(phase.col = "fase", terrgrid.id = 2),
boundary_weights = "boundaryweights",
small_area = list(sa.col = "idade", areas = c("3.7", "5.2"), unbiased = FALSE))
summary(reg2p_nex_est)
confint(reg2p_nex_est)
fun_erroSimulacoes = function(sd, volumeMed, alpha = 0.05, n) {
t = qt(1 - alpha/2, n - 1)
E = ((sd * t)/volumeMed) * 100
return(E)
}
nParcelas = c(20, 15, 10, 6, 5, 4, 3, 2) # Número de parcelas de campo
areaTotal = sum(talhoes$area)
# Simulações de Intensidade Amostral na Amostragem Dupla Simples
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
erroSimulacoes_ADS = round(fun_erroSimulacoes(sd = sqrt(reg2p_nex$estimation$g_variance),
volumeMed = mean(X$VTCC[!is.na(X$VTCC)]), n = nParcelas), 2)
IA_ADS = c()
foreach(i = 1:length(nParcelas)) %do% {
IA_ADS[i] =  round(areaTotal/nParcelas[i], 2)
}
# Cria quadro para apresentar a variação da intensidade amostral
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
quadroADS <- as.data.frame(
tibble(Erro_amostral = str_c(erroSimulacoes_ADS[1:length(nParcelas)], "%"),
Intensidade_amostral = str_c("1 parc / ", IA_ADS[1:length(nParcelas)], " ha"),
Numero_de_parcelas = nParcelas[1:length(nParcelas)])
)
quadroADS %>%
kbl(caption = paste0("Amostragem Dupla Simples em ~",
round(areaTotal, 0), " ha."), align = "c") %>%
kable_classic(full_width = F)
nParcelas = c(3500, 20, 15, 10, 6, 5, 4, 3, 2) # Número de parcelas de campo
areaTotal = sum(talhoes$area)
# Simulações de Intensidade Amostral na Amostragem Dupla Simples
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
erroSimulacoes_ADS = round(fun_erroSimulacoes(sd = sqrt(reg2p_nex$estimation$g_variance),
volumeMed = mean(X$VTCC[!is.na(X$VTCC)]), n = nParcelas), 2)
IA_ADS = c()
foreach(i = 1:length(nParcelas)) %do% {
IA_ADS[i] =  round(areaTotal/nParcelas[i], 2)
}
# Cria quadro para apresentar a variação da intensidade amostral
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
quadroADS <- as.data.frame(
tibble(Erro_amostral = str_c(erroSimulacoes_ADS[1:length(nParcelas)], "%"),
Intensidade_amostral = str_c("1 parc / ", IA_ADS[1:length(nParcelas)], " ha"),
Numero_de_parcelas = nParcelas[1:length(nParcelas)])
)
quadroADS %>%
kbl(caption = paste0("Amostragem Dupla Simples em ~",
round(areaTotal, 0), " ha."), align = "c") %>%
kable_classic(full_width = F)
# Simulações de Intensidade Amostral na Amostragem Dupla Estratificada
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
erroSimulacoes_ADE = round(fun_erroSimulacoes(sd = sqrt(reg2p_nex_est$estimation$g_variance),
volumeMed = mean(X$VTCC[!is.na(X$VTCC)]), n = nParcelas), 2)
IA_ADE = c()
foreach(i = 1:length(nParcelas)) %do% {
IA_ADE[i] =  round(areaTotal/nParcelas[i], 2)
}
# Cria quadro para apresentar a variação da intensidade amostral
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
quadroADE <- as.data.frame(
tibble(Erro_amostral = str_c(erroSimulacoes_ADE[1:length(nParcelas)], "%"),
Intensidade_amostral = str_c("1 parc / ", IA_ADE[1:length(nParcelas)], " ha"),
Numero_de_parcelas = nParcelas[1:length(nParcelas)])
)
quadroADE %>%
kbl(caption = paste0("Amostragem Dupla Estratificada em ~",
round(areaTotal, 0), " ha."), align = "c") %>%
kable_classic(full_width = F)
X$zq95
dsNumberOfPlots = function(y, x, xLarge, Cpg = 300,
errDesired = 0.1, alpha = 0.05){
rho = cor(x,y)
a = var(y) * (1 - rho^2)
b = var(y) * rho^2
B = errDesired * mean(y)
qt = qt(1 - alpha/2, length(y)-1)
nG = (sqrt( a*b*Cpg ) + b) / (B^2 / qt^2)
nP = (sqrt( a*b/Cpg ) + a) / (B^2 / qt^2)
return(nP)
}
teste = dsNumberOfPlots(x = X$zq95,
y = X$VTCC[!is.na(X$VTCC)])
teste = dsNumberOfPlots(x = X$zq95,
y = X$VTCC)
teste
teste = dsNumberOfPlots(x = X$zq95[!is.na(X$VTCC)],
y = X$VTCC[!is.na(X$VTCC)])
teste
dsNumberOfPlots = function(y, x, xLarge, Cpg = 250,
errDesired = 0.1, alpha = 0.05){
rho = cor(x,y)
a = var(y) * (1 - rho^2)
b = var(y) * rho^2
B = errDesired * mean(y)
qt = qt(1 - alpha/2, length(y)-1)
nG = (sqrt( a*b*Cpg ) + b) / (B^2 / qt^2)
nP = (sqrt( a*b/Cpg ) + a) / (B^2 / qt^2)
return(nP)
}
teste = dsNumberOfPlots(x = X$zq95[!is.na(X$VTCC)],
y = X$VTCC[!is.na(X$VTCC)])
teste
dsNumberOfPlots = function(y, x, xLarge, Cpg = 250,
errDesired = 0.05, alpha = 0.05){
rho = cor(x,y)
a = var(y) * (1 - rho^2)
b = var(y) * rho^2
B = errDesired * mean(y)
qt = qt(1 - alpha/2, length(y)-1)
nG = (sqrt( a*b*Cpg ) + b) / (B^2 / qt^2)
nP = (sqrt( a*b/Cpg ) + a) / (B^2 / qt^2)
return(nP)
}
teste = dsNumberOfPlots(x = X$zq95[!is.na(X$VTCC)],
y = X$VTCC[!is.na(X$VTCC)])
teste
teste = round(dsNumberOfPlots(x = X$zq95[!is.na(X$VTCC)],
y = X$VTCC[!is.na(X$VTCC)]), 0)
teste
total = areaTotal / teste
total
total = str_c("Para erro de 5%, 1 parcela a cada ", areaTotal / teste)
total
total = str_c("Para erro de 5%, 1 parcela a cada ", areaTotal / teste, " ha.")
total
dsNumberOfPlots = function(y, x, xLarge, Cpg = 300,
errDesired = 0.05, alpha = 0.05){
rho = cor(x,y)
a = var(y) * (1 - rho^2)
b = var(y) * rho^2
B = errDesired * mean(y)
qt = qt(1 - alpha/2, length(y)-1)
nG = (sqrt( a*b*Cpg ) + b) / (B^2 / qt^2)
nP = (sqrt( a*b/Cpg ) + a) / (B^2 / qt^2)
return(nP)
}
teste = round(dsNumberOfPlots(x = X$zq95[!is.na(X$VTCC)],
y = X$VTCC[!is.na(X$VTCC)]), 0)
total = str_c("Para erro de 5%, 1 parcela a cada ", areaTotal / teste, " ha.")
total
rm(list=ls(all=TRUE))                                   # Limpa memória
gc()
if(!require(tidyverse))
install.packages(tidyverse)
library(tidyverse)
# Leitura da versão mais atual do pacote rio
#           para importação de planilhas Excel
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
if (!require("remotes")){install.packages("remotes")}
if (!require(rio))      {remotes::install_github("gesistsa/rio")}
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Lê pacote forestinventory
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
if(!require(forestinventory))
install.packages("forestinventory")
library(forestinventory)
# Lê pacote foreach para criar loopings inteligentes
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
if(!require(foreach))
install.packages("foreach")
library(foreach)
# Lê pacote kableExtra para criar tabelas
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
if(!require(kableExtra))
install.packages("kableExtra")
library(kableExtra)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Amostragem Dupla - parâmetros do pacote
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Função:
# twophase(
#         formula  = Y ~ Z + W, Y é a variável medida no campo. Z e W são variáveis auxiliares,
#         data     = dataframe ou vetor com a variável Y,
#         phase_id = list (
#                         phase.col   = nome coluna id da fase,
#                         terrgrid.id = valor numérico do id da fase),
#         area     = list(
#                        sa.col = nome coluna de estratificação,
#                        areas  = vetor c("", "", "") de estratos), ubiased = TRUE para viés e FALSE para sem viés,
#         cluster  = nome da coluna, se houver cluster sampling)
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Define local e nome da planilha para leitura dos dados
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
prjNome  <- "PRJ_InvModelo"
dirNome  <- paste0('C:/GitHub/', prjNome, '/DADOS/')
arqNome_metricas  <- paste0(dirNome, prjNome, '_Metricas.xlsx')
arqNome_grid <- paste0(dirNome, prjNome, '.xlsx')
metricas     <- import(arqNome_metricas)
grid     <- import(arqNome_grid, which = "grid")
talhoes <- import(arqNome_grid, which = "talhoes")
# Mescla as métricas LiDAR com o Grid através da coluna "gridcell". Células do
# grid cuja área é menor do que 1m² são descartadas.
grid_laz <- merge(grid, metricas, by = "gridcell") %>%
filter_at(vars(areacell), all_vars(. >= 1))
# Seleciona colunas de interesse
X <- tibble(grid_laz) %>% select(fase, areacell, idade, zmean,
zsd, pzabovezmean, zq30, zq75, zq95, MHDOM, VTCC)
X$fase <- as.numeric(X$fase) # Converte a coluna "fase" para o tipo numérico
X$boundaryweights <- X$areacell / 400 # Cria a coluna "boundaryweights"
X <- as.data.frame(X) # Tibble não é uma função nativa do R, é uma função chamada pelo tidyverse. Dessa forma, o formato da tabela que é gerada não é reconhecido pela função twophase() do package forestinventory. O forestinventory reconhece data frames, já que são nativos do R.
# Análise de regressão linear para verificar a correlação
# entre o p95 e a idade do inventário com o VTCC
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
m <- lm(VTCC ~ zq95 + idade, data = X)    # Análise de Regressão Linear
summary(m)                          # Mostra os resultados da regressão
VTCCparcelas <- X$VTCC[!is.na(X$VTCC)] # VTCCparcelas recebe os valores não nulos de VTCC contidos em X, ou seja, recebe os valores de VTCC das parcelas de campo
plot(VTCCparcelas, predict(m))              # Gráfico de observado vs predito
abline(0,1)
# Dupla Amostragem Casual
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
reg2p_nex <- twophase(formula = VTCC ~ zq95 + idade, # formula relaciona os valores de VTCC com zq95 e IDINV (análise de regressão)
data = X, #  Base de dados utilizada
boundary_weights = "boundaryweights",
phase_id = list(phase.col = "fase", terrgrid.id = 2)) # phase_id recebe uma lista em que a coluna a ser analisada é a "Inventario" e o identificador da segunda fase é 2
summary(reg2p_nex) # Dá os resultados da Dupla Amostragem
confint(reg2p_nex) # Estatística de confiança
# Dupla Amostragem Estratificada
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
reg2p_nex_est = twophase(
formula = VTCC ~ zq95 + idade,
data = X,
phase_id =list(phase.col = "fase", terrgrid.id = 2),
boundary_weights = "boundaryweights",
small_area = list(sa.col = "idade", areas = c("3.7", "5.2"), unbiased = FALSE))
summary(reg2p_nex_est)
confint(reg2p_nex_est)
fun_erroSimulacoes = function(sd, volumeMed, alpha = 0.05, n) {
t = qt(1 - alpha/2, n - 1)
E = ((sd * t)/volumeMed) * 100
return(E)
}
nParcelas = c(20, 15, 10, 6, 5, 4, 3, 2) # Número de parcelas de campo
areaTotal = sum(talhoes$area)
# Simulações de Intensidade Amostral na Amostragem Dupla Simples
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
erroSimulacoes_ADS = round(fun_erroSimulacoes(sd = sqrt(reg2p_nex$estimation$g_variance),
volumeMed = mean(X$VTCC[!is.na(X$VTCC)]), n = nParcelas), 2)
IA_ADS = c()
foreach(i = 1:length(nParcelas)) %do% {
IA_ADS[i] =  round(areaTotal/nParcelas[i], 2)
}
# Cria quadro para apresentar a variação da intensidade amostral
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
quadroADS <- as.data.frame(
tibble(Erro_amostral = str_c(erroSimulacoes_ADS[1:length(nParcelas)], "%"),
Intensidade_amostral = str_c("1 parc / ", IA_ADS[1:length(nParcelas)], " ha"),
Numero_de_parcelas = nParcelas[1:length(nParcelas)])
)
quadroADS %>%
kbl(caption = paste0("Amostragem Dupla Simples em ~",
round(areaTotal, 0), " ha."), align = "c") %>%
kable_classic(full_width = F)
erroSimulacoes_ADE = round(fun_erroSimulacoes(sd = sqrt(reg2p_nex_est$estimation$g_variance),
volumeMed = mean(X$VTCC[!is.na(X$VTCC)]), n = nParcelas), 2)
IA_ADE = c()
foreach(i = 1:length(nParcelas)) %do% {
IA_ADE[i] =  round(areaTotal/nParcelas[i], 2)
}
# Cria quadro para apresentar a variação da intensidade amostral
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
quadroADE <- as.data.frame(
tibble(Erro_amostral = str_c(erroSimulacoes_ADE[1:length(nParcelas)], "%"),
Intensidade_amostral = str_c("1 parc / ", IA_ADE[1:length(nParcelas)], " ha"),
Numero_de_parcelas = nParcelas[1:length(nParcelas)])
)
quadroADE %>%
kbl(caption = paste0("Amostragem Dupla Estratificada em ~",
round(areaTotal, 0), " ha."), align = "c") %>%
kable_classic(full_width = F)
dsNumberOfPlots = function(y, x, xLarge, Cpg = 300,
errDesired = 0.05, alpha = 0.05){
rho = cor(x,y)
a = var(y) * (1 - rho^2)
b = var(y) * rho^2
B = errDesired * mean(y)
qt = qt(1 - alpha/2, length(y)-1)
nG = (sqrt( a*b*Cpg ) + b) / (B^2 / qt^2)
nP = (sqrt( a*b/Cpg ) + a) / (B^2 / qt^2)
return(nP)
}
teste = round(dsNumberOfPlots(x = X$zq95[!is.na(X$VTCC)],
y = X$VTCC[!is.na(X$VTCC)]), 0)
total = str_c("Para erro de 5%, 1 parcela a cada ", areaTotal / teste, " ha.")
total
teste
quadroACE %>%
kbl(caption = paste0("Amostragem Casual Estratificada em ~",
round(AreaTotal, 0), " ha."), align = "r") %>%
kable_classic(full_width = F) %>%
footnote(general       = NotaDeRodape,
general_title = "Intensidade amostral",
footnote_as_chunk = T)
if (!require("remotes")){install.packages("remotes")}
if (!require(rio))      {remotes::install_github("gesistsa/rio")}
library(rio)
# Define local e nome da planilha para leitura dos dados
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
prjNome <- 'PRJ_InvModelo'
dirNome <- paste0('C:/GitHub/', prjNome, '/DADOS/')
arqNome  <- paste0(dirNome, prjNome, '.xlsx')
talhoes  <- import(arqNome, which = "talhoes")
parcelas <- import(arqNome, which = "parcelas")
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Lê pacote forestinventory
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
if(!require(forestinventory))  # Para melhor manipulação de dados e funções
install.packages("forestinventory")
library(forestinventory)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Lê pacote tidyverse
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
if(!require(tidyverse))  # Para melhor manipulação de dados e funções
install.packages("tidyverse")
library(tidyverse)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Lê pacote kableExtra
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
if(!require(kableExtra))  # Para melhor manipulação de dados e funções
install.packages("kableExtra")
library(kableExtra)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Amostragem simples em fase única - parâmetros do pacote
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Função:
# onephase(
#         formula  = Y ~ 1, Y é a variável medida no campo,
#         data     = dataframe ou vetor com a variável Y,
#         phase_id = list (
#                         phase.col   = nome coluna id da fase,
#                         terrgrid.id = valor numérico do id da fase),
#         area     = list(
#                        sa.col = nome coluna de estratificação,
#                        areas  = vetor c("", "", "") de estratos),
#         cluster  = nome da coluna, se houver cluster sampling)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Amostragem Casual Simples (ACS)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ----
AreaTotal <- talhoes$area %>% sum             # Área total inventariada
# ACS <- onephase(formula  = MHDOM ~ 1,
ACS <- onephase(formula  = VTCC ~ 1,
data     = parcelas,
phase_id = list(phase.col = "fase", terrgrid.id = 1))
summary(ACS)
confint(ACS)
# Número Total de Unidades Amostrais (N) na população ~~~~~~~~~~~~~~~~~
erro         <- 0.05                                   # Erro desejado
tamMedioParc <- mean(parcelas$areapar) / 10000               # em ha
N            <- round(AreaTotal / tamMedioParc , 0)
# Função para cálculo da intensidade amostral desejável da ACS
#                           para garantir um certo erro mínimo
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tamanhoIdealACS = function(x, N, erro){
media = x$estimation$estimate
var   = x$estimation$variance
n     = x$estimation$n2
t     = qt(1 - erro/2, n -1)
B     = erro * media
ndsej = round((N * var * t^2) / (N * B^2 + var * t^2), 0)
lista = cbind(media, B, ndsej) %>% as.data.frame
colnames(lista) = c('media', 'bound', 'ndsej')
return(lista)
}
nACS <- tamanhoIdealACS(ACS, N, erro)
# Tabela com resultados do inventário (estimação + inferência) por ACS
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
IAS <- paste0(" usada: 1 parc/",
round( AreaTotal / ACS$estimation$n2, 0), " ha.")
IAI <- paste0("\n Necessárias p/ erro de ", erro*100, "%: 1 parc/",
round(AreaTotal / nACS$ndsej, 0), " ha.")
NotaDeRodape <- paste0(IAS, IAI)
quadroACS <- as.data.frame(
tibble(LimInf95   = confint(ACS)$ci$ci_lower_op,
Estimativa = ACS$estimation$estimate,
LimSup95   = confint(ACS)$ci$ci_upper_op,
Variância  = ACS$estimation$variance,
n          = ACS$estimation$n2))
quadroACS %>%
kbl(caption = paste0("Amostragem Casual Simples em ~",
round(AreaTotal, 0), " ha."), align = "r") %>%
kable_classic(full_width = F) %>%
footnote(general       = NotaDeRodape,
general_title = "Intensidade amostral",
footnote_as_chunk = T)
# ----
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Amostragem Casual Estratificada (ACE)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ----
AreaTotal <- talhoes$area %>% sum             # Área total inventariada
# ACE <- onephase(formula  = MHDOM ~ 1,
ACE <- onephase(formula  = VTCC ~ 1,
data     = parcelas,
phase_id = list(phase.col = "fase", terrgrid.id = 1),
area     = list(sa.col = "idade", areas = c(3.7, 5.2)))
summary(ACE)
confint(ACE)
# Número Total de Unidades Amostrais (N) por estrato na população ~~~~~
erro         <- 0.05                                  # Erro desejado
tamMedioParc <- mean(parcelas$areapar) / 10000               # em ha
N            <- round(AreaTotal / tamMedioParc, 0)
Nh           <- round(tapply(talhoes$area, talhoes$idade, FUN=sum) /
tamMedioParc, 0)
# Função para cálculo da intensidade amostral desejável da ACE
# para garantir um certo erro mínimo.
#                               Shiver&Borders (1996, pág 129 eq. 5.10)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tamanhoIdealACE = function(x, N, Nh, erro){
media = sum( Nh * x$estimation$estimate ) / N
var   = x$estimation$variance
dh    = sqrt(var)
wh    = (Nh*dh) / sum(Nh*dh)    # desconsiderada diferença nos custos
B     = erro * media
ndsej = round(sum( (Nh^2 * var) / wh ) /
( (N^2  * B^2) / 4 + sum(Nh * var) ), 0)
lista = cbind(media, B, ndsej) %>% as.data.frame
colnames(lista) = c('media', 'bound', 'ndsej')
return(lista)
}
nACE <- tamanhoIdealACE(ACE, N, Nh, erro)
# Tabela com resultados do inventário (estimação + inferência) por ACE
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
IAS <- paste0(" usada: 1 parc/",
round( AreaTotal / sum(ACE$estimation$n2), 0), " ha.")
IAI <- paste0("\n Necessárias p/ erro de ", erro*100, "%: 1 parc/",
round(AreaTotal / nACE$ndsej, 0), " ha.")
NotaDeRodape <- paste0(IAS, IAI)
quadroACE <- as.data.frame(
tibble(
Estrato    = ACE$estimation$area,
LimInf95   = confint(ACE)$ci$ci_lower_op,
Estimativa = ACE$estimation$estimate,
LimSup95   = confint(ACE)$ci$ci_upper_op,
Variância  = ACE$estimation$variance,
n          = ACE$estimation$n2))
quadroACE %>%
kbl(caption = paste0("Amostragem Casual Estratificada em ~",
round(AreaTotal, 0), " ha."), align = "r") %>%
kable_classic(full_width = F) %>%
footnote(general       = NotaDeRodape,
general_title = "Intensidade amostral",
footnote_as_chunk = T)
nACE$ndsej
